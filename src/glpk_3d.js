
import Glpk from 'glpk.js';


export default class GlpkBimonoidalLayout {
    constructor(diagram) {
        this.diag = diagram;
        this.edgeDist = 15.0; 
        this.margins = 15.0;
        this.avgEpsilon = 0.1;

    }

    /**
     * Solves the constraints with GLPK to deduce node and path positions.
     */
    compute() {
        let program = this.getWireConstraints(true);
        let solutions = Glpk.solve(program);
        if (solutions.result.status === 1) {
            // switch to lax mode if the strict set of constraints is unsatisfiable
            program = this.getWireConstraints(false);
            solutions = Glpk.solve(program);
        }
        this.solutions = solutions.result.vars;

        // post process the node positions for swaps, to make sure unrelated wires
        // do not end up at the same place
        let minDist = 3;
        for (let i = 0; i < this.diag.nbVertices(); i++) {
            if (this.diag.isSwap(i)) {
                let nbNodes = this.diag.nbNodesOnVertex(i);
                for (let j = 0; j < nbNodes; j++) {
                    for (let k = j+1; k < nbNodes; k++) {
                        if (this.solutions[`node${i}_${k}`] - this.solutions[`node${i}_${j}`] < minDist) {
                            this.solutions[`node${i}_${k}`] += minDist/2;
                            this.solutions[`node${i}_${j}`] -= minDist/2;
                        }
                    }
                }
            }
        }
    }

    getNodePosition(vertexId, nodeId) {
        return this.solutions[`node${vertexId}_${nodeId}`];
    }

    getPathPosition(edgeId, pathId) {
        return this.solutions[`w${edgeId}_${pathId}`];
    }

    getSheetWidth() {
        return this.solutions['rb'];
    }

    /**
     * Computes a GLPK program for the positions of wires
     * on sheets.
     * The boolean strict parameter determines whether we should 
     * produce a stricter set of constraints, which can fail on some
     * diagrams but produce a better output in most diagrams.
     */
    getWireConstraints(strictMode) {
       // weighted list of all variables appearing in the program.
       // we minimize their sum as objective.
       let allVars = [
         {name: 'lb', coef: 1.0},
         {name: 'rb', coef: 1.0}
       ];
       // list of all constraints generated by the wires.
       let constraints = [{
           name: 'lb',
           vars: [
              { name: 'lb', coef: 1.0 },
           ],
           bnds: { type: Glpk.GLP_FX, ub: 0.0, lb: 0.0 }
        }];

        // For each sheet
        for(let i = 0; i < this.diag.nbEdges(); i++) {
            let paths = this.diag.getPathsOnEdge(i);
    
            // space out all the wires on this sheet
            for(let j = 0; j < paths.length; j++) {
                allVars.push({
                   name: `w${i}_${j}`,
                   coef: 1.0
                });

                if (j === 0) {
                    constraints.push({
                        name: `wire_r${i}_${j}`,
                        vars: [
                            { name: `w${i}_${j}`, coef: 1.0 }
                        ],
                        bnds: { type: Glpk.GLP_LO, ub: 0.0, lb: this.margins }
                    });
                }

                let rightEdge = 'rb';
                let dist = this.margins;
                if (j < paths.length - 1) {
                    rightEdge = `w${i}_${j+1}`;
                    dist = this.edgeDist;
                }
                constraints.push({
                    name: `wire_${i}_${j}`,
                    vars: [
                        { name: rightEdge, coef: 1.0 },
                        { name: `w${i}_${j}`, coef: -1.0 }
                    ],
                    bnds: { type: Glpk.GLP_LO, ub: 0.0, lb: dist }
                });
            }
        }

        // For each seam
        for(let i = 0; i < this.diag.nbVertices(); i++) {
            // For each node on that seam
            for(let j = 0; j < this.diag.nbNodesOnVertex(i); j++) {
                let varName = `node${i}_${j}`;
                allVars.push({
                        name: varName,
                        coef: 1.0
                });

                // Ensure the node is positioned after the previous one
                // but only if the node is not a swap, in which case we do not care
                if (! this.diag.isSwap(i)) {
                    if (j == 0) {
                            constraints.push({
                                    name: `node${i}_${j}_left`,
                                    vars: [
                                            { name: varName, coef: 1.0 }
                                    ],
                                    bnds: { type: Glpk.GLP_LO, ub: 0.0, lb: this.margins }
                            });
                    } else {
                            constraints.push({
                                    name: `node${i}_${j}_left`,
                                    vars: [
                                            { name: varName, coef: 1.0 },
                                            { name: `w${i}_${j-1}`, coef: -1.0 }
                                    ],
                                    bnds: { type: Glpk.GLP_LO, ub: 0.0, lb: this.edgeDist }
                            });
                    }
                    if (j == this.diag.nbNodesOnVertex(i) - 1) {
                            constraints.push({
                                    name: `node${i}_${j}_right`,
                                    vars: [
                                            { name: 'rb', coef: 1.0 },
                                            { name: varName, coef: -1.0 }
                                    ],
                                    bnds: { type: Glpk.GLP_LO, ub: 0.0, lb: this.margins }
                            });
                    }
                }
                
                let incomingPaths = this.diag.getIncomingPaths(i, j);
                if (strictMode) {
                    // For each sheet, node is centered around the mean of the input wires on that sheet
                    let sheetsAbove = this.diag.edgesAtLevel(i);
                    let vertex = this.diag.getVertex(i);
                    for(let k = vertex.offset; k < vertex.offset + vertex.inputs; k++) {
                        let paths = incomingPaths.filter(t => t[0] == sheetsAbove[k]);
                        this.centerAround(constraints, varName, paths, varName + `_inputs_${k}`);
                    } 
                } else {
                    // Node is centered around the mean of all its inputs
                    this.centerAround(constraints, varName, incomingPaths, varName + '_inputs');
                }

                // Vertex is centered around the mean of its outputs
                let outgoingPaths = this.diag.getOutgoingPaths(i, j);
                if (strictMode) {
                    // For each sheet, node is centered around the mean of the output wires on that sheet
                    let sheetsBelow = this.diag.edgesAtLevel(i+1);
                    let vertex = this.diag.getVertex(i);
                    for(let k = vertex.offset; k < vertex.offset + vertex.outputs; k++) {
                        let paths = outgoingPaths.filter(t => t[0] == sheetsBelow[k]);
                        this.centerAround(constraints, varName, paths, varName + `_outputs_${k}`);
                    } 
                } else {
                    // Node is centered around the mean of all its outputs
                    this.centerAround(constraints, varName, outgoingPaths, varName + '_outputs');
                }
            }
        }

        let program = {
           name: 'LP',
           objective: {
              direction: Glpk.GLP_MIN,
              name: 'obj',
              vars: allVars
           },
           subjectTo: constraints
        };
        return program;
    }

    centerAround(constraints, vertexVar, wireVars, constraintName) {
        let inputVars = [{name: vertexVar, coef: -1.0}];
        for(let k = 0; k < wireVars.length; k++) {
            inputVars.push({
                name: `w${wireVars[k][0]}_${wireVars[k][1]}`,
                coef: 1.0 / wireVars.length
            });
        }
        if (wireVars.length > 0) {
            constraints.push({
                name: constraintName,
                vars: inputVars,
                bnds: { type: Glpk.GLP_DB, ub: this.avgEpsilon, lb: -this.avgEpsilon },
            });
        }
    }
}
